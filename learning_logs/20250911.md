```python
try:
    a = int(input('나누는 수를 정수로 입력하세요 >>> '))
    b = int(input('나누어지는 수를 정수로 입력하세요 >>> '))
    result = b/a # 예외가 발생할 수 있는 구간이 try문 내에 있어야만 한다. 
except ZeroDivisionError as e:
    print(e)
except TypeError as e:
    print(e)
except ValueError as e:
    print(e)
except Exception as e:
    print(e)
else:
    print(f'b/a {b / a}')
finally:
    print('프로그램이 종료되었습니다.')


```
결과적으로 개발자가 고려해야할 것은 일단 try를 써버리면 except 안썼을 때 오류가 발생하기때문에  try / except문이 없는 상태에서 다양하게 검증해보고 어떤 예외가 발생하는지 체크해야한다.
그리고 발생한 예외들에 대한 except문을 작성해야하고, 정상적으로 처리가 되었을 때 else문을 쓸 필요가 있다.

하지만 이상의 사례와 같이 a = 0 을 입력하는 것 자체가 예외를 발생시키지 않고,
1. a=0 이면서,
2. b / a 연산을 시도할 때 ZeroDivisionError가 발생하기 때문에
else문에 b/a가 포함되어서는 안된다.
그래서 try문에 result = b / a를 넣어줌으로써 그 부분이 예외없이 통과되었을 때만 연산 결과가 출력될 수 있도록 `print(f'b/a={result}`로 정리했다.


# 상속

```python
'''
상속
형식 :
class 수퍼클래스:
    번믄

class 서브클래스(수퍼클래스):
    본문

'''

class Person:
    def __init__(self, name):
        self.name = name

    def eat(self, food):
        print(f'{self.name}이(가) {food}를 먹습니다.')

class Student(Person):
    def __init__(self, name, school):
        super().__init__(name)
        self.school = school

    def study(self):
        print(f'{self.name}은(는) {self.school}에서 공부를 합니다')

potter = Student('해리포터', '호그와트')
potter.eat('감자')
potter.study()

```
이상의 코드에서 주목해야할 점은
1. Student 클래스에 정의되지않은 메서드인 .eat()을 호출했다는 점
2. Student 클래스의 생성자에서 확인되는 `super().__init__(name)`이다.
   - 해당 부분은 수퍼 클래스의 생성자를 호출하는 방식이다.
   - 자바에서는 수퍼 클래스의 생성자 호출방식이 super()
   - 자바에서 수퍼 클래스의 메서드 호출방식 super.메서드명()

```python
    def eat(self, food):
        print(f'{self.school}에서', end=' ')
        super().eat(food)


```
수퍼 클래스의 메서드인 .eat()를 오버라이드하여 `재정의`하는 것도 가능하다.
자바와 달리 파이썬은 기본적으로 `super()`.을 베이스로 한다는 것을 알 수 있다.
생성자나 소멸자에 __가 앞뒤로 붙기는 하지만 기본적으로 메서드라는 사실을 알고있다면 자바보다 오히려 더 일괄적인 방식으로 코드를 작성한다는 것도 확인할 수 있다.