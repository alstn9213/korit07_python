
```python
class Student:
    def __init__(self, name, student_id):
        self._name: name
        self._student_id = student_id
        # 성적을 저장하기 위한 빈 딕셔너리 -> 과목명이 key, 점수가 value
        self._grades = {}
```

1. 저번에 Java버전의 setter / getter를 생성했다.
    - 그런데 Java에는 access modifier 개념이 있었기 때문에 field를 private로 선언했다면 setter / getter 는 필수적이다.
    - 문제는 python에는 access modifier라고 할만한 개념이 없기 때문에 모든 객체의 속성이 외부로 노출된다.
2. 이상을 이유로 python에서는 `_속성명` 이라고 명시하면, `내부적으로만 사용하라고 권장되는 변수'라고 개발자들끼리 약속한 개념에 가깝다.
3. name vs. _name
    - name
        - 공개적로 접근가능한 속성(Public Attribute)
        - 클래스 외부에서 자유롭게 값을 읽고 쓸 수 있으며, 다른 개발자가 이 변수를 사용해도 괜찮음.
        - 예시 : student.name = '김일'과 같이 직접 접근하여 사용
    - _name
      - 내부용 또는 비공개 속성(Private Attribute)
      - python에는 java와 같은 엄격한 접근 제어자가 없어서 _를 붙여 '외부에서 접근하지 마세요'같은 의미만 전달.
      - 이런 변수는 일반적으로 `@property` 데코레이터를 사용한 getter와 setter를 경유하여 간접적으로 접근하는 것이 올바른 방법.

# JPA에서의 객체생성 vs. python에서의 객체생성
JPA(Java Persistence API)를 사용한 Java에서는 기본 생성자를 강제한다.(springboot에서도 적용된다). 그런데 python에서는 매개변수 생성자를 '권장'하는데 이는 두 언어 간의 객체지향 패러다임과 데이터 관리방식의 차이에 기인한다.

1. java(JPA)에서의 기본생성자
   - JPA는 DB의 테이블과 (엔티티)클래스를 매핑하여 객체를 관리한다.(엔티티 클래스의 field가 DB에서의 컬럼 명이 된다.) 이 과정에서 JPA가 자기 매개변수를 알 수는 없기때문에 매개변수가 없는 기본 생성자를 먼저 호출하여 객체를 생성하고 DB에서의 컬럼값들을 하나씩 필드에 넣어준다. 이상을 이유로 JPA는 데이터 관리의 일관성과 효율성을 위해 기본생성자를 강제한다.

```java
@Entity
@Data
public class Student {
    private String name;
    private int studentCode;
    
    public Student(){}
}
    
public class StudentMain {
    main {
        Student student1 = new Student();
        student1.setName('김일');
        student1.setStudentCode(2025001);
        }
    }

```
이상의 코드라인처럼 일단 필드에 아무런 값이 없는 객체를 생성한 후에, DB상에서의 테이블에 있는 값들을 일치하는 컬럼명을 조회해서 넣어주는 과정을 거치기 때문에 기본 생성자를 강제한다.

2. python에서의 매개변수 생성자
   - 파이썬은 자바와 달리 동적 타이핑(Dynamic Typing)언어라고 해서, 객체를 생성할 때 필수 속성들을 한번에 초기화하는 것을 권장한다.
     1. 객체 무결성 보장 : init 메서드(생성자)에서 모든 필수 매개변수를 받으면, 객체가 생성되는 시점에 이미 완전한 상태를 갖게 된다. -> 그 값이 적절한가는 추후에 따진다.
     2. 명확한 코드작성 : 클래스를 사용하는 사람이 어떤 정보가 필요한지를 명확하게 알 수 있다. 자바처럼 순서대로 하는 것도 아니고 keyword argument를 지원하기도 하니까.
   
그리고 파이썬과 db의 연동에 있어서 JPA처럼 값을 하나씩 넣기보다는 ORM(Object-Relation Mapping)라이브러리를 통해 객체를 생성할 때 필요한 데이터를 직접 전달하는 방식으로 JPA와의 차이점이 있어 기본 생성자를 강제할 필요가 없다.

* 요약: JPA는 DB와 연동하기 위한 기술적 제약으로 인해 기본 생성자를 명시해야하는 귀찮은 점이 있는데 (매개변수 생성자를 하나라도 정의하는 순간 기본 생성자도 정의해야한다.) 파이썬은 객체의 완전성과 가독성을 중시하는 언어적 특성상 매개변수 생성자를 더 권장한다.

bank_account -> main
ch08_coffee_machine / pop_version / oop_version


```python
MENU = {
    '에스프레소': {
        '재료': {
            '물': 50,
            '커피': 18,
        },
        '가격': 1.5,
    },
    '라떼': {
        '재료': {
            '물': 200,
            '우유': 150,
            '커피': 24,
        },
        '가격': 2.5,
    },
    '카푸치노': {
        '재료': {
            '물': 250,
            '우유': 100,
            '커피': 24,
        },
        '가격': 3.0,
    },
}

# 실행 예
# 카푸치노에는 우유가 100ml가 들어갑니다.
# 라고 출력할 수 있도록 카푸치노의 우유량을 추출하는 코드작성

# 에소프레소의 가격을 추출

# 라떼의 재료를 재료 이름만 출력

ca_milk = MENU['카푸치노']['재료']['우유']
print(f'카푸치노에는 우유가 {ca_milk}ml가 들어갑니다.')

eso_price = MENU['에스프레소']['가격']
print(eso_price)

for gradient in MENU['라떼']['재료']: # dictionary 에서 반복문을 돌리면 key가 나온다. 그리고 그 key를 이용해서 value조회가능
    print(gradient, end=" ")
print()
print(' '.join(MENU['라떼']['재료'].keys()))

'''
에소프레소 / 라떼 / 카푸치노를 50잔씩 만든다고 가정했을 때 필요한 커피 / 우유 / 물의 양
'''

coffee = 0
water = 0
milk = 0

for key in MENU:
    for key_key in MENU[key]['재료']:
        if key_key == '커피':
            coffee += MENU[key]['재료'][key_key]
        elif key_key == '물':
            water += MENU[key]['재료'][key_key]
        else:
            milk += MENU[key]['재료'][key_key]

print(coffee*50)
print(water*50)
print(milk*50)

'''
중첩적으로 이루어진 dictionary - JSON - collections 들이 합쳐진 데이터에서 내가 필요한 부분을 어떻게 추출할 수 있을까이다.
일반적으로 list의 경우 index를 사용하기 때문에 반복문쓰고 치우면 그만인데 dictionary는 반복문을 돌리면 key가 나오고 그 key를 또 이용해야하지만 value가 추출된다.
그리고 그 value를 이용해서 연산을 하거나 로직을 작성해야한다.
근데 value가 또 dictionary거나 list거나 혹은 객체거나 한 경우엔 복잡해진다.

'''


```